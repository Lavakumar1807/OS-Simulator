<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inter Process Communication</title>
  <link href="./css/styles.css" rel ="stylesheet">
  <link href="./css/output.css" rel="stylesheet" >
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
  <style>
      /* Base Styles */
:root {
  --primary-color: #00b4d8;
  --secondary-color: #0077b6;
  --accent-color: #48cae4;
  --dark-bg: #121212;
  --card-bg: #1e1e1e;
  --text-primary: #f8f9fa;
  --text-secondary: #adb5bd;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --danger-color: #f44336;
  --border-radius: 8px;
  --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  --transition-speed: 0.3s;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: var(--dark-bg);
  color: var(--text-primary);
  line-height: 1.6;
  overflow-x: hidden;
  position: relative;
  min-height: 100vh;
}

.container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 15px;
}

a {
  text-decoration: none;
  color: var(--primary-color);
  transition: color var(--transition-speed);
}

a:hover {
  color: var(--accent-color);
}

/* Particle Background */
.particle-background {
  position: fixed;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  z-index: -1;
}

/* Navigation Bar */
.navbar {
  background-color: rgba(20, 20, 20, 0.9);
  backdrop-filter: blur(10px);
  position: sticky;
  top: 0;
  width: 100%;
  z-index: 1000;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 0;
}

.logo {
  display: flex;
  align-items: center;
  font-weight: bold;
  font-size: 1.5rem;
  color: var(--primary-color);
}

.logo i {
  margin-right: 8px;
  font-size: 1.8rem;
}

.nav-links {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 40px;
}

.nav-links a {
  color: var(--text-secondary);
  padding: 8px 12px;
  border-radius: var(--border-radius);
  transition: all var(--transition-speed);
  display: flex;
  align-items: center;
}

.nav-links a i {
  margin-right: 6px;
}

.nav-links a:hover, .nav-links a.active {
  color: var(--text-primary);
  background-color: rgba(255, 255, 255, 0.05);
}

.nav-links a.active {
  color: var(--primary-color);
}

  </style>
</head>
<body>
   <!-- Particle Background -->
   <div class="particle-background" id="particles-js"></div>
    
   <!-- Navigation Bar (New) -->
   <nav class="navbar">
       <div class="container nav-container">
           <div class="logo">
               <i class="fas fa-microchip"></i>
               <span>OSphere</span>
           </div>
           <div class="nav-links">
               <a href="../../index.html" class="active"><i class="fas fa-home"></i> Home</a>
               <a href="../../collaborators.html"><i class="fa-solid fa-user-group"></i>Collaborators</a>
           </div>
       </div>
      </nav>

  
  <div class="out-container">
      <div class="text-container">
          
          <span class="paragraph-container">
              <strong>Inter Process Communication</strong>
             
                  <br>
                  <p class="mx-10">Inter-Process Communication (IPC) is a mechanism that allows processes
                     to communicate with each other and synchronize their actions. Since each process in an
                      operating system runs in its own isolated memory space, IPC is necessary for processes
                       to share data or signals.<br>
                      </p>
          </span>
          <br>
          </div>
          <div class ="text-container">
          <span class="paragraph-container">
              <br>
              <strong> Popular Methods </strong>
          <br>
                  <p class="mx-10">
                     <ol>
                      <li>1. Pipes
                        Unidirectional communication.
                        
                        Usually used between parent and child processes.
                        
                        Named Pipes (FIFOs) allow unrelated processes to communicate.</li>
                        <li>2. Message Queues
                          A system-managed queue for exchanging structured messages.
                          
                          Processes can send and receive messages asynchronously.</li>
                        <li>3. Shared Memory
                          Fastest IPC method.
                          
                          Processes share a region of memory and access it directly.
                          
                          Needs additional synchronization (e.g., semaphores) to prevent conflicts.</li>
                        <li>4. Semaphores
                          Used mainly for synchronization.
                          
                          Control access to shared resources.</li>
                        <li>5. Sockets
                          Allow communication between processes on the same or different machines.
                          
                          Basis for network communication (e.g., client-server model).</li>
                        <li>6. Signals
                          A limited form of IPC used to notify a process that an event has occurred.
                          
                          More suitable for small control messages than data sharing.
                          
                          </li>
                     </ol>
                  </p>
                  <br>                
          </span>
      </div>
  
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>CreateFileMapping()</strong>
      <p>
          The CreateFileMapping() function in the Windows
          API is used to create a file mapping object, which
          can be used to map a file (or a portion of a file) into
          memory. This is an essential function in memory-mapped 
          file I/O operations, allowing you to work with files as
          if they were part of the process's virtual memory space. 
          By using memory mapping, you can efficiently access large
          files without explicitly using traditional read and write functions.
      </p>
  </span>

</div>
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong>Syntax:</strong><p>
          <ul>
              HANDLE CreateFileMapping(

  <li class="vartype">HANDLE hFile,               // Handle to the file to be mapped</li>
  <li class="vartype"> LPSECURITY_ATTRIBUTES lpAttributes, // Security attributes</li>
  <li class="vartype"> DWORD flProtect,            // Protection for the mapping (e.g., read/write)</li>
  <li class="vartype">DWORD dwMaximumSizeHigh,    // High-order DWORD of the maximum size</li>
  <li class="vartype">DWORD dwMaximumSizeLow,     // Low-order DWORD of the maximum size</li>
  <li class="vartype">LPCTSTR lpName              // Name of the mapping object (optional));</li>

              
 </ul></p>
</span>

</div>
<div class="text-container">
<span class="paragraph-container">
  <br>
<strong>Parameters:</strong>
<ul>
<li>hFile:

  A handle to the file to be mapped. This handle can
   be obtained by using the CreateFile() function.
    If hFile is INVALID_HANDLE_VALUE, a mapping is created
     for a section of the file that is not 
  associated with an actual file (anonymous mapping).</li>

<li>flProtect:

  The protection for the memory mapping. This value
   specifies the access rights for the 
  mapped memory. Common values include:
<li class="vartype">PAGE_READONLY: The mapping is read-only.</li>

<li class="vartype">PAGE_READWRITE: The mapping is read-write.</li>

<li class="vartype">PAGE_WRITECOPY: The mapping is read-write, 
  but changes do not affect the original file.</li>

</li>
<li>dwMaximumSizeHigh and dwMaximumSizeLow:

  These parameters specify the maximum size of the
   mapping, divided into high and low 32-bit values.
    If the hFile parameter refers to an existing file,
     these values define the size of the file mapping.
      If hFile is INVALID_HANDLE_VALUE, this represents the
       size of the mapping.

</li>
<li>
  lpName:

A pointer to a null-terminated string that specifies
the name of the file mapping object. If this parameter is
NULL, the mapping object is unnamed and can only be 
accessed by the process that created it.
</li>
</ul>
</p>
</span>

</div>

<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>OpenFileMapping()</strong>
      <p>
          The OpenFileMapping() function is part of the Windows API and is
           used to open an existing named file mapping object. This 
           function is primarily used in inter-process communication 
           (IPC), allowing different processes to access a shared memory
            region that was created using CreateFileMapping().

Once a process has access to the file mapping object (via
OpenFileMapping()), it can use MapViewOfFile() to map the shared memory
into its address space and read/write data as if it were regular
 memory.
      </p>
  </span>

</div>
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong>Syntax:</strong><p>
          <ul>
              HANDLE OpenFileMapping(

  <li class="vartype">DWORD   dwDesiredAccess,   // Access rights to mapping object</li>
  <li class="vartype"> BOOL    bInheritHandle,    // Can child processes inherit the handle?</li>
  <li class="vartype">LPCTSTR lpName             // Name of the file mapping object</li>
  <li>);</li>
  

              
 </ul></p>
</span>

</div>
<div class="text-container">
<span class="paragraph-container">
  <br>
<strong>Parameters:</strong>
<ul>
<li>dwDesiredAccess:

  The access level the process needs to the mapping object.
  
  Common values:
  
  FILE_MAP_READ: Read access
  
  FILE_MAP_WRITE: Write access
  
  FILE_MAP_ALL_ACCESS: Full access (read/write)
</li>

<li>bInheritHandle:

  Set to TRUE if the returned handle can be inherited by child processes.
  
  Otherwise, set to FALSE.

</li>
<li>lpName:

  The name of the file mapping object to open. This must match
  the name 
  used when the object was created with CreateFileMapping().

</li>
</ul>
</p>
</span>

</div>



<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>MapViewOfFile()</strong>
      <p>
          MapViewOfFile is a Windows API function that allows a process 
          to map a view of a file into its address space. This is commonly
          used for memory-mapped file I/O, which enables a program to access
          file contents directly through memory rather than using traditional
          read/write functions. This can offer performance benefits,
          particularly for large files or when multiple processes need to
          share data.
      </p>
  </span>

</div>
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong>Syntax:</strong><p>
          <ul>
              LPVOID MapViewOfFile(

  <li class="vartype">HANDLE hFileMappingObject,</li>
  <li class="vartype">DWORD  dwDesiredAccess,</li>
  <li class="vartype">DWORD  dwFileOffsetHigh,</li>
  <li class="vartype">DWORD  dwFileOffsetLow,</li>
  <li class="vartype">SIZE_T dwNumberOfBytesToMap</li>
  <li>);</li>
  

              
 </ul></p>
</span>

</div>
<div class="text-container">
<span class="paragraph-container">
  <br>
<strong>Parameters:</strong>
<ul>
<li>hFileMappingObject: A handle to a file mapping
   object. This is created using CreateFileMapping.
</li>

<li>dwDesiredAccess: The type of access to the file view 
  (e.g., FILE_MAP_READ, FILE_MAP_WRITE, FILE_MAP_ALL_ACCESS).

</li>
<li>dwFileOffsetHigh / dwFileOffsetLow: Specify the starting point of the file mapping 
  (split into high and low DWORDs for 64-bit support).

</li>
<li>
  dwNumberOfBytesToMap: Number of bytes to map. If 0, the entire file is mapped from the offset.
</li>
</ul>
</p>
</span>

</div>

<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>FileMemoryMapping</strong>
  </span>

</div>
<div id="FileMemoryMapping" class="text-container" >
<textarea  class="auto-resize-textarea" placeholder="Write your code here"  id="FileMemoryMappingInput"></textarea>
</div>
<button class="bg-black text-white rounded w-32 justify-center" id="FileMemoryMappingRun">Run</button>
<div id="FileMemoryMappingOutputContainer" class="text-container">
<textarea class="auto-resize-textarea" placeholder="output" id="FileMemoryMappingOutput"></textarea>
</div>




<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>MemoryMappedRead</strong>
  </span>

</div>
<div id="MemoryMappedRead" class="text-container" >
<textarea  class="auto-resize-textarea" placeholder="Write your code here"  id="MemoryMappedReadInput"></textarea>
</div>


<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>CreateNamedPipe()</strong>
      <p>
          This function creates an instance of a named pipe
          and sets it up for one end (usually the server side)
          to perform read/write operations. The client connects to
          it using CreateFile
      </p>
  </span>

</div>
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong>Syntax:</strong><p>
          <ul>
              HANDLE CreateNamedPipe(
  <li class="vartype">LPCSTR                lpName,</li>
  <li class="vartype">DWORD                 dwOpenMode,</li>
  <li class="vartype">DWORD                 dwPipeMode,</li>
  <li class="vartype">DWORD                 nMaxInstances,</li>
  <li class="vartype">DWORD                 nOutBufferSize,</li>
  <li class="vartype">DWORD                 nInBufferSize,</li>
  <li class="vartype">DWORD                 nDefaultTimeOut,</li>
  <li class="vartype">LPSECURITY_ATTRIBUTES lpSecurityAttributes</li>
  <li>);</li>
  

              
 </ul></p>
</span>

</div>
<div class="text-container">
<span class="paragraph-container">
  <br>
<strong>Parameters:</strong>
<ul>
<li>lpName: The name of the pipe.
   Format: \\.\pipe\YourPipeName
</li>

<li>dwOpenMode: How the pipe will be opened. Combines flags like:
  <ul>
  <li class="vartype">PIPE_ACCESS_INBOUND – Server reads</li>
  
  <li class="vartype">PIPE_ACCESS_OUTBOUND – Server writes</li>
  
  <li class="vartype">PIPE_ACCESS_DUPLEX – Server can read and write</li>
</ul>
</li>
<li>dwPipeMode: Communication behavior. Can include:
  <ul>
  <li class="vartype">PIPE_TYPE_BYTE or PIPE_TYPE_MESSAGE</li>
  
  <li class="vartype">PIPE_READMODE_BYTE or PIPE_READMODE_MESSAGE</li>
  
  <li class="vartype">PIPE_WAIT or PIPE_NOWAIT</li>
</ul>
</li>
<li>nMaxInstances: Max number of simultaneous pipe instances 
  (e.g., 1 to 255)

</li>
<li>
  nOutBufferSize / nInBufferSize: Size of the output and
   input buffers in bytes
</li>
<li>
  nDefaultTimeOut: Default timeout in milliseconds for 
  pipe operations
</li>
<li>
  lpSecurityAttributes: Optional security descriptor
</li>
</ul>
</p>
</span>

</div>

<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>ReadFile()</strong>
      <p>
          ReadFile reads data from a file or I/O device into a buffer.
      </p>
  </span>

</div>
<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong>Syntax:</strong><p>
          <ul>
              BOOL ReadFile(
  <li class="vartype">HANDLE       hFile,</li>
  <li class="vartype">LPVOID       lpBuffer,</li>
  <li class="vartype">DWORD        nNumberOfBytesToRead,</li>
  <li class="vartype">LPDWORD      lpNumberOfBytesRead,</li>
  <li class="vartype">LPOVERLAPPED lpOverlapped</li>
  <li>);</li>
  

              
 </ul></p>
</span>

</div>
<div class="text-container">
<span class="paragraph-container">
  <br>
<strong>Parameters:</strong>
<ul>
<li>hFile: A handle to the file or I/O device. 
  Must be opened with GENERIC_READ.
</li>

<li>lpBuffer: Pointer to a buffer that receives the data.
</li>
<li>nNumberOfBytesToRead: Number of bytes to attempt to read.
</li>
<li>lpNumberOfBytesRead: Pointer to a variable that receives the number
   of bytes actually read.

</li>
<li>
  lpOverlapped: Pointer to an OVERLAPPED structure (used for async I/O). 
  If NULL, the read is synchronous.
</li>
</ul>
</p>
</span>

</div>

<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>Pipe</strong>
  </span>

</div>
<div id="Pipe" class="text-container" >
<textarea  class="auto-resize-textarea" placeholder="Write your code here"  id="PipeInput"></textarea>
</div>


<div class="text-container">
  <span class="paragraph-container">
      <br>
      <strong><br>PipeRead</strong>
  </span>

</div>
<div id="PipeRead" class="text-container" >
<textarea  class="auto-resize-textarea" placeholder="Write your code here"  id="PipeReadInput"></textarea>
</div>



</div>
</div>
  <script src="ipc.js"></script>
</body>
</html>